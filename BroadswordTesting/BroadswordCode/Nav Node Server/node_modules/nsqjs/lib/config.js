// Generated by CoffeeScript 1.12.2
var ConnectionConfig, ReaderConfig, _, url,
  slice = [].slice,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('underscore');

url = require('url');

ConnectionConfig = (function() {
  var isBareAddress;

  ConnectionConfig.DEFAULTS = {
    authSecret: null,
    clientId: null,
    deflate: false,
    deflateLevel: 6,
    heartbeatInterval: 30,
    maxInFlight: 1,
    messageTimeout: null,
    outputBufferSize: null,
    outputBufferTimeout: null,
    requeueDelay: 90,
    sampleRate: null,
    snappy: false,
    tls: false,
    tlsVerification: true
  };

  function ConnectionConfig(options) {
    if (options == null) {
      options = {};
    }
    options = _.chain(options).pick(_.keys(this.constructor.DEFAULTS)).defaults(this.constructor.DEFAULTS).value();
    _.extend(this, options);
  }

  ConnectionConfig.prototype.isNonEmptyString = function(option, value) {
    if (!(_.isString(value) && value.length > 0)) {
      throw new Error(option + " must be a non-empty string");
    }
  };

  ConnectionConfig.prototype.isNumber = function(option, value, lower, upper) {
    if (upper == null) {
      upper = null;
    }
    if (_.isNaN(value) || !_.isNumber(value)) {
      throw new Error(option + "(" + value + ") is not a number");
    }
    if (upper) {
      if (!((lower <= value && value <= upper))) {
        throw new Error(lower + " <= " + option + "(" + value + ") <= " + upper);
      }
    } else {
      if (!(lower <= value)) {
        throw new Error(lower + " <= " + option + "(" + value + ")");
      }
    }
  };

  ConnectionConfig.prototype.isNumberExclusive = function(option, value, lower, upper) {
    if (upper == null) {
      upper = null;
    }
    if (_.isNaN(value) || !_.isNumber(value)) {
      throw new Error(option + "(" + value + ") is not a number");
    }
    if (upper) {
      if (!((lower < value && value < upper))) {
        throw new Error(lower + " < " + option + "(" + value + ") < " + upper);
      }
    } else {
      if (!(lower < value)) {
        throw new Error(lower + " < " + option + "(" + value + ")");
      }
    }
  };

  ConnectionConfig.prototype.isBoolean = function(option, value) {
    if (!_.isBoolean(value)) {
      throw new Error(option + " must be either true or false");
    }
  };

  isBareAddress = function(addr) {
    var host, port, ref;
    ref = addr.split(':'), host = ref[0], port = ref[1];
    return host.length > 0 && port > 0;
  };

  ConnectionConfig.prototype.isBareAddresses = function(option, value) {
    if (!(_.isArray(value) && _.every(value, isBareAddress))) {
      throw new Error(option + " must be a list of addresses 'host:port'");
    }
  };

  ConnectionConfig.prototype.isLookupdHTTPAddresses = function(option, value) {
    var isAddr;
    isAddr = function(addr) {
      var parsedUrl, ref;
      if (addr.indexOf('://') === -1) {
        return isBareAddress(addr);
      }
      parsedUrl = url.parse(addr);
      return ((ref = parsedUrl.protocol) === 'http:' || ref === 'https:') && !!parsedUrl.host;
    };
    if (!(_.isArray(value) && _.every(value, isAddr))) {
      throw new Error(option + " must be a list of addresses 'host:port' or HTTP/HTTPS URI");
    }
  };

  ConnectionConfig.prototype.conditions = function() {
    return {
      authSecret: [this.isNonEmptyString],
      clientId: [this.isNonEmptyString],
      deflate: [this.isBoolean],
      deflateLevel: [this.isNumber, 0, 9],
      heartbeatInterval: [this.isNumber, 1],
      maxInFlight: [this.isNumber, 1],
      messageTimeout: [this.isNumber, 1],
      outputBufferSize: [this.isNumber, 64],
      outputBufferTimeout: [this.isNumber, 1],
      requeueDelay: [this.isNumber, 0],
      sampleRate: [this.isNumber, 1, 99],
      snappy: [this.isBoolean],
      tls: [this.isBoolean],
      tlsVerification: [this.isBoolean]
    };
  };

  ConnectionConfig.prototype.validateOption = function(option, value) {
    var args, fn, ref;
    ref = this.conditions()[option], fn = ref[0], args = 2 <= ref.length ? slice.call(ref, 1) : [];
    return fn.apply(null, [option, value].concat(slice.call(args)));
  };

  ConnectionConfig.prototype.validate = function() {
    var keys, option, ref, value;
    ref = this;
    for (option in ref) {
      value = ref[option];
      if (_.isFunction(value)) {
        continue;
      }
      if (_.isNull(value) && this.constructor.DEFAULTS[option] === null) {
        continue;
      }
      keys = ['outputBufferSize', 'outputBufferTimeout'];
      if (indexOf.call(keys, option) >= 0 && value === -1) {
        continue;
      }
      this.validateOption(option, value);
    }
    if (this.snappy && this.deflate) {
      throw new Error('Cannot use both deflate and snappy');
    }
  };

  return ConnectionConfig;

})();

ReaderConfig = (function(superClass) {
  extend(ReaderConfig, superClass);

  function ReaderConfig() {
    return ReaderConfig.__super__.constructor.apply(this, arguments);
  }

  ReaderConfig.DEFAULTS = _.extend({}, ConnectionConfig.DEFAULTS, {
    lookupdHTTPAddresses: [],
    lookupdPollInterval: 60,
    lookupdPollJitter: 0.3,
    name: null,
    nsqdTCPAddresses: [],
    maxAttempts: 0,
    maxBackoffDuration: 128
  });

  ReaderConfig.prototype.conditions = function() {
    return _.extend({}, ReaderConfig.__super__.conditions.call(this), {
      lookupdHTTPAddresses: [this.isLookupdHTTPAddresses],
      lookupdPollInterval: [this.isNumber, 1],
      lookupdPollJitter: [this.isNumberExclusive, 0, 1],
      name: [this.isNonEmptyString],
      nsqdTCPAddresses: [this.isBareAddresses],
      maxAttempts: [this.isNumber, 0],
      maxBackoffDuration: [this.isNumber, 0]
    });
  };

  ReaderConfig.prototype.validate = function() {
    var addresses, i, key, len, pass;
    addresses = ['nsqdTCPAddresses', 'lookupdHTTPAddresses'];
    for (i = 0, len = addresses.length; i < len; i++) {
      key = addresses[i];
      if (_.isString(this[key])) {
        this[key] = [this[key]];
      }
    }
    ReaderConfig.__super__.validate.apply(this, arguments);
    pass = _.chain(addresses).map((function(_this) {
      return function(key) {
        return _this[key].length;
      };
    })(this)).any(_.identity).value();
    if (!pass) {
      throw new Error("Need to provide either " + (addresses.join(' or ')));
    }
  };

  return ReaderConfig;

})(ConnectionConfig);

module.exports = {
  ConnectionConfig: ConnectionConfig,
  ReaderConfig: ReaderConfig
};
